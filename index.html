<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Nugget's Yarn Maze</title>
  <style>
    body {
      margin: 0;
      background-color: #fef6e4;
      font-family: 'Arial', sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }
    
    canvas {
      display: block;
      margin: 20px auto;
      background-color: #fff8dc;
      border: 2px solid #333;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }
    
    #gameContainer {
      position: relative;
    }
    
    #startButton, #pauseOverlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 16px 32px;
      font-size: 20px;
      background-color: #f9c5d1;
      border: 2px solid #333;
      border-radius: 8px;
      cursor: pointer;
      z-index: 10;
      text-align: center;
    }
    
    #pauseOverlay {
      background-color: rgba(249, 197, 209, 0.95);
      padding: 30px;
      display: none;
    }
    
    #instructions {
      margin-top: 20px;
      padding: 20px;
      background-color: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      max-width: 512px;
      text-align: center;
    }
    
    .controls {
      display: flex;
      justify-content: space-around;
      margin: 10px 0;
      flex-wrap: wrap;
    }
    
    .control {
      background-color: #f0f0f0;
      padding: 5px 10px;
      border-radius: 4px;
      margin: 2px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <button id="startButton">Start Game</button>
    <div id="pauseOverlay">
      <h2>Game Paused</h2>
      <p>Press SPACE or ESC to resume</p>
    </div>
    <canvas id="gameCanvas" width="512" height="512"></canvas>
  </div>
  
  <div id="instructions">
    <h3>How to Play</h3>
    <p>Help Nugget collect all the yarn while avoiding the cats!</p>
    <div class="controls">
      <span class="control">Arrow Keys: Move</span>
      <span class="control">Space/ESC: Pause</span>
    </div>
    <p>ðŸ§¶ Blue yarn = 1 point | âœ¨ Gold yarn = 5 points + invincibility!</p>
  </div>

  <script>
    // Constants
    const TILE_SIZE = 32;
    const PLAYER_SPEED = 2.4;
    const INVINCIBLE_DURATION = 360;
    const ENEMY_RESPAWN_TIME = 360;
    const WIN_ANIMATION_DURATION = 240;
    const LEVEL_TRANSITION_DELAY = 3000;
    const MAX_ENEMIES = 6;
    
    // Game States
    const GAME_STATE = {
      MENU: 0,
      PLAYING: 1,
      PAUSED: 2,
      WON: 3,
      GAME_OVER: 4,
      LEVEL_TRANSITION: 5
    };
    
    // Game elements
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const startButton = document.getElementById("startButton");
    const pauseOverlay = document.getElementById("pauseOverlay");

    const map = [
      "################",
      "#......##......#",
      "#.####.##.####.#",
      "#..............#",
      "#.####.##.####.#",
      "#..............#",
      "####.#.##.#.####",
      "####.#.##.#.####",
      "####.#.##.#.####",
      "#..............#",
      "#.####.##.####.#",
      "#......##......#",
      "#.####.##.####.#",
      "#o............o#",
      "################"
    ];

    // Asset loading with fallbacks
    const nuggetImgs = {
      up: new Image(),
      down: new Image(),
      left: new Image(),
      right: new Image(),
      cheer1: new Image(),
      cheer2: new Image(),
      cheer3: new Image()
    };
    
    // Load images with error handling
    const loadImage = (img, src, fallbackColor = '#ff69b4') => {
      img.src = src;
      img.onerror = () => {
        console.warn(`Failed to load image: ${src}`);
        img.fallbackColor = fallbackColor;
      };
    };
    
    loadImage(nuggetImgs.up, "nugget_up.png");
    loadImage(nuggetImgs.down, "nugget_down.png");
    loadImage(nuggetImgs.left, "nugget_left.png");
    loadImage(nuggetImgs.right, "nugget_right.png");
    loadImage(nuggetImgs.cheer1, "nugget_cheer1.png");
    loadImage(nuggetImgs.cheer2, "nugget_cheer2.png");
    loadImage(nuggetImgs.cheer3, "nugget_cheer3.png");

    const yarnImg = new Image();
    const specialYarnImg = new Image();
    const catImg = new Image();
    const bgWin = new Image();
    
    loadImage(yarnImg, "yarn_blue.png", '#4169e1');
    loadImage(specialYarnImg, "yarn_gold.png", '#ffd700');
    loadImage(catImg, "cat_enemy.png", '#8b4513');
    loadImage(bgWin, "win_background.png", '#90ee90');

    // Audio with error handling
    const createAudio = (src) => {
      const audio = new Audio();
      audio.src = src;
      audio.addEventListener('error', () => console.warn(`Failed to load audio: ${src}`));
      return audio;
    };

    const sfxYarn = createAudio("yarn_collect.mp3");
    const sfxSpecial = createAudio("powerup.mp3");
    const sfxMeow = createAudio("meow.mp3");
    const sfxInvincible = createAudio("invincible_loop.mp3");
    const sfxStart = createAudio("start_game.mp3");
    const sfxGameOver = createAudio("game_over.mp3");
    const sfxGameWon = createAudio("game_won.mp3");
    const bgMusic = createAudio("bg_music.mp3");
    
    sfxInvincible.loop = true;
    bgMusic.loop = true;

    // Game state
    let currentState = GAME_STATE.MENU;
    let player = {
      x: TILE_SIZE,
      y: TILE_SIZE * 3,
      dirX: 1,
      dirY: 0,
      direction: "right",
      speed: PLAYER_SPEED,
      invincible: 0
    };

    let enemies = [];
    let yarns = [];
    let specialYarns = [];
    let score = 0;
    let level = 1;
    let winAnimationCounter = 0;
    let inputBuffer = null;
    let levelTransitionTimer = 0;

    // Game initialization
    function initYarns() {
      yarns = [];
      specialYarns = [];
      for (let y = 0; y < map.length; y++) {
        for (let x = 0; x < map[y].length; x++) {
          if (map[y][x] === '.') yarns.push({ x, y });
          if (map[y][x] === 'o') specialYarns.push({ x, y });
        }
      }
    }

    function spawnEnemies(count) {
      enemies = [];
      const enemySpeed = PLAYER_SPEED + (level * 0.2);
      const enemyCount = Math.min(count, MAX_ENEMIES);
      
      for (let i = 0; i < enemyCount; i++) {
        enemies.push({
          x: TILE_SIZE * (7 + (i % 2)),
          y: TILE_SIZE * 7,
          speed: enemySpeed,
          alive: true,
          respawn: 0,
          moveX: 0,
          moveY: 0,
          targetSet: false
        });
      }
    }

    function resetGame() {
      player.x = TILE_SIZE;
      player.y = TILE_SIZE * 3;
      player.dirX = 1;
      player.dirY = 0;
      player.direction = "right";
      player.speed = PLAYER_SPEED;
      player.invincible = 0;
      
      score = 0;
      level = 1;
      inputBuffer = null;
      initYarns();
      spawnEnemies(level + 1);
      currentState = GAME_STATE.PLAYING;
    }

    function nextLevel() {
      level++;
      score += 100 * level; // Level completion bonus
      initYarns();
      spawnEnemies(level + 1);
      
      // Reset player position
      player.x = TILE_SIZE;
      player.y = TILE_SIZE * 3;
      player.dirX = 1;
      player.dirY = 0;
      player.direction = "right";
      player.invincible = 0;
      
      currentState = GAME_STATE.LEVEL_TRANSITION;
      levelTransitionTimer = LEVEL_TRANSITION_DELAY;
    }

    // Utility functions
    function canMove(x, y) {
      const col = Math.floor(x / TILE_SIZE);
      const row = Math.floor(y / TILE_SIZE);
      return map[row] && map[row][col] !== '#';
    }

    function playAudio(audio) {
      try {
        audio.currentTime = 0;
        audio.play().catch(e => console.warn('Audio play failed:', e));
      } catch (e) {
        console.warn('Audio error:', e);
      }
    }

    // Game logic
    function updatePlayer() {
      if (currentState !== GAME_STATE.PLAYING) return;
      
      const cx = Math.floor((player.x + TILE_SIZE / 2) / TILE_SIZE);
      const cy = Math.floor((player.y + TILE_SIZE / 2) / TILE_SIZE);
      const aligned = Math.abs(player.x % TILE_SIZE - TILE_SIZE / 2) < 2 && 
                     Math.abs(player.y % TILE_SIZE - TILE_SIZE / 2) < 2;

      // Handle input buffer
      if (aligned && inputBuffer) {
        if (canMove((cx + inputBuffer.x) * TILE_SIZE, (cy + inputBuffer.y) * TILE_SIZE)) {
          player.dirX = inputBuffer.x;
          player.dirY = inputBuffer.y;
          inputBuffer = null;
        }
      }

      // Move player
      const nextX = player.x + player.dirX * player.speed;
      const nextY = player.y + player.dirY * player.speed;
      if (canMove(nextX, nextY)) {
        player.x = nextX;
        player.y = nextY;
      }

      // Update direction for sprite
      if (player.dirX === 1) player.direction = "right";
      else if (player.dirX === -1) player.direction = "left";
      else if (player.dirY === -1) player.direction = "up";
      else if (player.dirY === 1) player.direction = "down";

      // Cache player tile position
      const playerTileX = Math.floor((player.x + TILE_SIZE / 2) / TILE_SIZE);
      const playerTileY = Math.floor((player.y + TILE_SIZE / 2) / TILE_SIZE);

      // Collect yarns
      yarns = yarns.filter(dot => {
        if (dot.x === playerTileX && dot.y === playerTileY) {
          score++;
          playAudio(sfxYarn);
          return false;
        }
        return true;
      });

      // Collect special yarns
      specialYarns = specialYarns.filter(dot => {
        if (dot.x === playerTileX && dot.y === playerTileY) {
          player.invincible = INVINCIBLE_DURATION;
          score += 5;
          playAudio(sfxSpecial);
          playAudio(sfxInvincible);
          return false;
        }
        return true;
      });

      // Handle invincibility
      if (player.invincible > 0) {
        player.invincible--;
        if (player.invincible === 0) {
          sfxInvincible.pause();
        }
      }
    }

    function updateEnemies() {
      if (currentState !== GAME_STATE.PLAYING) return;
      
      const playerTileX = Math.floor((player.x + TILE_SIZE / 2) / TILE_SIZE);
      const playerTileY = Math.floor((player.y + TILE_SIZE / 2) / TILE_SIZE);

      enemies.forEach(e => {
        if (!e.alive) {
          e.respawn--;
          if (e.respawn <= 0) {
            e.x = TILE_SIZE * 7;
            e.y = TILE_SIZE * 7;
            e.alive = true;
            e.targetSet = false;
          }
          return;
        }

        // Optimized AI - only recalculate when centered or blocked
        const centered = Math.abs(e.x % TILE_SIZE) < 2 && Math.abs(e.y % TILE_SIZE) < 2;
        if (centered || !e.targetSet) {
          const dx = player.x - e.x;
          const dy = player.y - e.y;
          e.moveX = Math.abs(dx) > Math.abs(dy) ? Math.sign(dx) : 0;
          e.moveY = Math.abs(dx) <= Math.abs(dy) ? Math.sign(dy) : 0;
          e.targetSet = true;
        }

        // Move enemy
        const nextX = e.x + e.moveX * e.speed;
        const nextY = e.y + e.moveY * e.speed;
        if (canMove(nextX, nextY)) {
          e.x = nextX;
          e.y = nextY;
        } else {
          e.targetSet = false; // Recalculate when blocked
        }

        // Check collision with player
        const ex = Math.floor((e.x + TILE_SIZE / 2) / TILE_SIZE);
        const ey = Math.floor((e.y + TILE_SIZE / 2) / TILE_SIZE);

        if (playerTileX === ex && playerTileY === ey) {
          if (player.invincible > 0) {
            e.alive = false;
            e.respawn = ENEMY_RESPAWN_TIME;
            score += 10;
            playAudio(sfxMeow);
          } else {
            currentState = GAME_STATE.GAME_OVER;
            playAudio(sfxGameOver);
            bgMusic.pause();
            setTimeout(() => {
              alert("Game Over! Nugget got caught! Final Score: " + score);
              currentState = GAME_STATE.MENU;
              startButton.style.display = "block";
              startButton.innerText = "Play Again";
            }, 100);
          }
        }
      });
    }

    function updateGame() {
      switch (currentState) {
        case GAME_STATE.PLAYING:
          updatePlayer();
          updateEnemies();
          
          // Check win condition
          if (yarns.length === 0 && specialYarns.length === 0) {
            currentState = GAME_STATE.WON;
            playAudio(sfxGameWon);
            winAnimationCounter = 0;
          }
          break;
          
        case GAME_STATE.WON:
          winAnimationCounter++;
          if (winAnimationCounter >= WIN_ANIMATION_DURATION) {
            nextLevel();
          }
          break;
          
        case GAME_STATE.LEVEL_TRANSITION:
          levelTransitionTimer--;
          if (levelTransitionTimer <= 0) {
            currentState = GAME_STATE.PLAYING;
          }
          break;
      }
    }

    // Rendering functions
    function drawImage(img, x, y, width, height, fallbackColor) {
      if (img.complete && img.naturalWidth > 0) {
        ctx.drawImage(img, x, y, width, height);
      } else if (img.fallbackColor || fallbackColor) {
        ctx.fillStyle = img.fallbackColor || fallbackColor;
        ctx.fillRect(x, y, width, height);
      }
    }

    function drawMap() {
      for (let y = 0; y < map.length; y++) {
        for (let x = 0; x < map[y].length; x++) {
          ctx.fillStyle = map[y][x] === '#' ? "#d9d4b0" : "#fff8dc";
          ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
        }
      }
    }

    function drawYarns() {
      yarns.forEach(dot => {
        drawImage(yarnImg, dot.x * TILE_SIZE + 8, dot.y * TILE_SIZE + 8, 16, 16, '#4169e1');
      });
      specialYarns.forEach(dot => {
        drawImage(specialYarnImg, dot.x * TILE_SIZE + 8, dot.y * TILE_SIZE + 8, 16, 16, '#ffd700');
      });
    }

    function drawPlayer() {
      if (player.invincible > 0) {
        ctx.fillStyle = "rgba(255, 255, 0, 0.3)";
        ctx.fillRect(player.x, player.y, TILE_SIZE, TILE_SIZE);
      }
      drawImage(nuggetImgs[player.direction], player.x, player.y, TILE_SIZE, TILE_SIZE, '#ff69b4');
    }

    function drawEnemies() {
      enemies.forEach(e => {
        if (e.alive) {
          drawImage(catImg, e.x, e.y, TILE_SIZE, TILE_SIZE, '#8b4513');
        }
      });
    }

    function drawUI() {
      ctx.fillStyle = "#000";
      ctx.font = "bold 18px Arial";
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 3;
      
      const scoreText = `Score: ${score}`;
      const levelText = `Level: ${level}`;
      
      ctx.strokeText(scoreText, 10, 25);
      ctx.fillText(scoreText, 10, 25);
      
      ctx.strokeText(levelText, 10, 50);
      ctx.fillText(levelText, 10, 50);
      
      if (player.invincible > 0) {
        const invText = `Invincible: ${Math.ceil(player.invincible / 60)}s`;
        ctx.strokeText(invText, canvas.width - 150, 25);
        ctx.fillText(invText, canvas.width - 150, 25);
      }
    }

    function drawWinAnimation() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Background
      if (bgWin.complete && bgWin.naturalWidth > 0) {
        ctx.drawImage(bgWin, 0, 0, canvas.width, canvas.height);
      } else {
        ctx.fillStyle = "#90ee90";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
      
      // Text
      ctx.fillStyle = "#000";
      ctx.font = "bold 36px Arial";
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 2;
      
      const winText = "ðŸŽ‰ Level Complete! ðŸŽ‰";
      const scoreText = `Score: ${score}`;
      const levelText = `Level: ${level}`;
      
      ctx.strokeText(winText, 80, 100);
      ctx.fillText(winText, 80, 100);
      
      ctx.font = "20px Arial";
      ctx.strokeText(scoreText, 190, 140);
      ctx.fillText(scoreText, 190, 140);
      
      ctx.strokeText(levelText, 200, 170);
      ctx.fillText(levelText, 200, 170);

      // Animated Nugget
      let frame;
      const animFrame = winAnimationCounter % 60;
      if (animFrame < 20) frame = nuggetImgs.cheer1;
      else if (animFrame < 40) frame = nuggetImgs.cheer2;
      else frame = nuggetImgs.cheer3;
      
      drawImage(frame, canvas.width / 2 - 40, canvas.height / 2 - 40, 80, 80, '#ff69b4');
    }

    function drawLevelTransition() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawMap();
      drawYarns();
      drawPlayer();
      drawEnemies();
      
      // Overlay
      ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      ctx.fillStyle = "#fff";
      ctx.font = "bold 32px Arial";
      ctx.textAlign = "center";
      
      const levelText = `Level ${level}`;
      const readyText = "Get Ready!";
      
      ctx.fillText(levelText, canvas.width / 2, canvas.height / 2 - 20);
      ctx.fillText(readyText, canvas.width / 2, canvas.height / 2 + 20);
      
      ctx.textAlign = "left";
    }

    function render() {
      switch (currentState) {
        case GAME_STATE.PLAYING:
        case GAME_STATE.PAUSED:
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          drawMap();
          drawYarns();
          drawPlayer();
          drawEnemies();
          drawUI();
          break;
          
        case GAME_STATE.WON:
          drawWinAnimation();
          break;
          
        case GAME_STATE.LEVEL_TRANSITION:
          drawLevelTransition();
          break;
      }
    }

    // Input handling
    document.addEventListener("keydown", e => {
      if (currentState === GAME_STATE.PLAYING) {
        const keyMap = {
          "ArrowUp": { x: 0, y: -1 },
          "ArrowDown": { x: 0, y: 1 },
          "ArrowLeft": { x: -1, y: 0 },
          "ArrowRight": { x: 1, y: 0 }
        };
        
        if (keyMap[e.key]) {
          e.preventDefault();
          inputBuffer = keyMap[e.key];
        }
      }
      
      // Pause functionality
      if ((e.key === " " || e.key === "Escape") && 
          (currentState === GAME_STATE.PLAYING || currentState === GAME_STATE.PAUSED)) {
        e.preventDefault();
        if (currentState === GAME_STATE.PLAYING) {
          currentState = GAME_STATE.PAUSED;
          pauseOverlay.style.display = "block";
          bgMusic.pause();
        } else {
          currentState = GAME_STATE.PLAYING;
          pauseOverlay.style.display = "none";
          playAudio(bgMusic);
        }
      }
    });

    // Game loop
    function gameLoop() {
      updateGame();
      render();
      requestAnimationFrame(gameLoop);
    }

    // Start button handler
    startButton.onclick = () => {
      startButton.style.display = "none";
      pauseOverlay.style.display = "none";
      resetGame();
      playAudio(bgMusic);
      playAudio(sfxStart);
    };

    // Initialize and start
    gameLoop();
  </script>
</body>
</html>
