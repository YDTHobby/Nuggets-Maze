<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Nugget's Yarn Maze</title>
  <style>
    body {
      margin: 0;
      background-color: #fef6e4;
      font-family: 'Arial', sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }
    canvas {
      display: block;
      margin: 20px auto;
      background-color: #fff8dc;
      border: 2px solid #333;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }
    #gameContainer {
      position: relative;
    }
    #startButton, #pauseOverlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 16px 32px;
      font-size: 20px;
      background-color: #f9c5d1;
      border: 2px solid #333;
      border-radius: 8px;
      cursor: pointer;
      z-index: 10;
      text-align: center;
    }
    #pauseOverlay {
      background-color: rgba(249, 197, 209, 0.95);
      padding: 30px;
      display: none;
    }
    #instructions {
      margin-top: 20px;
      padding: 20px;
      background-color: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      max-width: 512px;
      text-align: center;
    }
    .controls {
      display: flex;
      justify-content: space-around;
      margin: 10px 0;
      flex-wrap: wrap;
    }
    .control {
      background-color: #f0f0f0;
      padding: 5px 10px;
      border-radius: 4px;
      margin: 2px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <button id="startButton">Start Game</button>
    <div id="pauseOverlay">
      <h2>Game Paused</h2>
      <p>Press SPACE or ESC to resume</p>
    </div>
    <canvas id="gameCanvas" width="512" height="512"></canvas>
  </div>

  <div id="instructions">
    <h3>How to Play</h3>
    <p>Help Nugget collect all the yarn while avoiding the cat!</p>
    <div class="controls">
      <span class="control">Arrow Keys: Move</span>
      <span class="control">Space/ESC: Pause</span>
    </div>
    <p>ðŸ¥¶ Blue yarn = 1 point | âœ¨ Gold yarn = 5 points + invincibility!</p>
  </div>

<script>
  // === Constants ===
  const TILE_SIZE = 32;
  const PLAYER_SPEED = 1.92;
  const ENEMY_SPEED_BASE = 1.92;
  const INVINCIBLE_DURATION = 360;
  const ENEMY_SPAWN_DELAY = 480;
  const WIN_ANIMATION_DURATION = 1000;
  const LEVEL_TRANSITION_DELAY = 3000;

  const GAME_STATE = {
    MENU: 0,
    PLAYING: 1,
    PAUSED: 2,
    WON: 3,
    GAME_OVER: 4,
    LEVEL_TRANSITION: 5
  };

  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const startButton = document.getElementById('startButton');
  const pauseOverlay = document.getElementById('pauseOverlay');

  const gatePositions = [];
  for (let c = 4; c <= 11; c++) gatePositions.push({ row: 6, col: c });
  const spawnPoint = { row: 7, col: 7 };

  // === Game State ===
  let currentState = GAME_STATE.MENU;
  let player = {
    x: TILE_SIZE,
    y: TILE_SIZE * 3,
    dirX: 1,
    dirY: 0,
    direction: 'right',
    speed: PLAYER_SPEED,
    invincible: 0
  };
  let enemies = [], yarns = [], specialYarns = [];
  let score = 0, level = 1, winAnim = 0, inputBuf = null, transTimer = 0;
  let gatesOpen = false, frameCounter = 0;

  // === Map Layout ===
  const map = [
    '################',
    '#......##......#',
    '#.####.##.####.#',
    '#..............#',
    '#.####.##.####.#',
    '#..............#',
    '###.########.###',
    '###.#......#.###',
    '###.########.###',
    '#..............#',
    '#.####.##.####.#',
    '#......##......#',
    '#.####.##.####.#',
    '#o............o#',
    '################'
  ];

  // === Asset Loading ===
  const nuggetImgs = {
    up: new Image(), down: new Image(), left: new Image(), right: new Image(),
    cheer1: new Image(), cheer2: new Image(), cheer3: new Image()
  };
  function loadImage(img, src, fallback) {
    img.src = src;
    img.onerror = () => img.fallbackColor = fallback;
  }
  loadImage(nuggetImgs.up, 'nugget_up.png', '#ff69b4');
  loadImage(nuggetImgs.down, 'nugget_down.png', '#ff69b4');
  loadImage(nuggetImgs.left, 'nugget_left.png', '#ff69b4');
  loadImage(nuggetImgs.right, 'nugget_right.png', '#ff69b4');
  loadImage(nuggetImgs.cheer1, 'nugget_cheer1.png', '#ff69b4');
  loadImage(nuggetImgs.cheer2, 'nugget_cheer2.png', '#ff69b4');
  loadImage(nuggetImgs.cheer3, 'nugget_cheer3.png', '#ff69b4');

  const yarnImg = new Image(), specialYarnImg = new Image(), catImg = new Image(), bgWin = new Image();
  loadImage(yarnImg, 'yarn_blue.png', '#4169e1');
  loadImage(specialYarnImg, 'yarn_gold.png', '#ffd700');
  loadImage(catImg, 'cat_enemy.png', '#8b4513');
  loadImage(bgWin, 'win_background.png', '#90ee90');

  // === Audio ===
  function createAudio(src) {
    const a = new Audio(src);
    a.addEventListener('error', () => {});
    return a;
  }
  const sfxYarn = createAudio('yarn_collect.mp3');
  const sfxSpecial = createAudio('powerup.mp3');
  const sfxMeow = createAudio('meow.mp3');
  const sfxInvincible = createAudio('invincible_loop.mp3'); sfxInvincible.loop = true;
  const sfxStart = createAudio('start_game.mp3');
  const sfxGameOver = createAudio('game_over.mp3');
  const sfxGameWon = createAudio('game_won.mp3');
  const bgMusic = createAudio('bg_music.mp3'); bgMusic.loop = true;

  function playAudio(a) {
    try {
      a.pause();
      a.currentTime = 0;
      a.play();
    } catch {}
  }
  // === Initialize Yarns ===
  function initYarns() {
    yarns = [];
    specialYarns = [];
    map.forEach((row, r) => {
      row.split('').forEach((ch, c) => {
        if (ch === '.') yarns.push({ x: c, y: r });
        if (ch === 'o') specialYarns.push({ x: c, y: r });
      });
    });
    // remove yarns inside spawn room
    yarns = yarns.filter(d => !(d.y === spawnPoint.row && d.x >= spawnPoint.col - 2 && d.x <= spawnPoint.col + 3));
  }

  // === Spawn Enemy ===
  function spawnEnemies() {
    enemies = [];
    const e = {
      x: spawnPoint.col * TILE_SIZE,
      y: spawnPoint.row * TILE_SIZE,
      speed: ENEMY_SPEED_BASE + (level * 0.15 * 0.8),
      alive: false,
      respawn: 0,
      moveX: 0,
      moveY: 0,
      targetSet: false,
      intelligence: Math.min(0.3 + level * 0.1, 0.9),
      lastDir: 0
    };
    enemies.push(e);
  }

  // === Reset & Next Level ===
  function resetGame() {
    player.x = TILE_SIZE;
    player.y = TILE_SIZE * 3;
    player.dirX = 1;
    player.dirY = 0;
    player.direction = 'right';
    player.speed = PLAYER_SPEED;
    player.invincible = 0;

    score = 0;
    level = 1;
    inputBuf = null;

    initYarns();
    spawnEnemies();
    gatesOpen = false;
    frameCounter = 0;

    currentState = GAME_STATE.PLAYING;
    playAudio(bgMusic);
  }

  function nextLevel() {
    level++;
    score += 100 * level;
    initYarns();
    spawnEnemies();
    gatesOpen = false;
    frameCounter = 0;
    currentState = GAME_STATE.LEVEL_TRANSITION;
    transTimer = LEVEL_TRANSITION_DELAY;
  }

  // === Input ===
  document.addEventListener('keydown', e => {
    if (currentState === GAME_STATE.PLAYING) {
      const km = {
        'ArrowUp': { x: 0, y: -1 },
        'ArrowDown': { x: 0, y: 1 },
        'ArrowLeft': { x: -1, y: 0 },
        'ArrowRight': { x: 1, y: 0 }
      };
      if (km[e.key]) {
        e.preventDefault();
        inputBuf = km[e.key];
      }
    }
    if ((e.key === ' ' || e.key === 'Escape') &&
      (currentState === GAME_STATE.PLAYING || currentState === GAME_STATE.PAUSED)) {
      e.preventDefault();
      if (currentState === GAME_STATE.PLAYING) {
        currentState = GAME_STATE.PAUSED;
        pauseOverlay.style.display = 'block';
        bgMusic.pause();
      } else {
        currentState = GAME_STATE.PLAYING;
        pauseOverlay.style.display = 'none';
        playAudio(bgMusic);
      }
    }
  });

  // === Movement Helper ===
  function canMove(x, y, forEnemy = false) {
    const col = Math.floor((x + TILE_SIZE / 2) / TILE_SIZE);
    const row = Math.floor((y + TILE_SIZE / 2) / TILE_SIZE);
    const ch = map[row] && map[row][col];
    if (ch !== '#') return true;
    if (forEnemy && gatesOpen)
      for (const g of gatePositions)
        if (g.row === row && g.col === col) return true;
    return false;
  }
  // === Update Player ===
  function updatePlayer() {
    if (currentState !== GAME_STATE.PLAYING) return;

    const px = Math.floor((player.x + TILE_SIZE / 2) / TILE_SIZE);
    const py = Math.floor((player.y + TILE_SIZE / 2) / TILE_SIZE);
    const aligned = Math.abs(player.x - px * TILE_SIZE) < 4 && Math.abs(player.y - py * TILE_SIZE) < 4;

    if (aligned && inputBuf) {
      const tx = (px + inputBuf.x) * TILE_SIZE;
      const ty = (py + inputBuf.y) * TILE_SIZE;
      if (canMove(tx, ty)) {
        player.dirX = inputBuf.x;
        player.dirY = inputBuf.y;
        inputBuf = null;
      }
    }

    const nx = player.x + player.dirX * player.speed;
    const ny = player.y + player.dirY * player.speed;

    if (canMove(nx, ny)) {
      player.x = nx;
      player.y = ny;
    } else {
      player.x = px * TILE_SIZE;
      player.y = py * TILE_SIZE;
      player.dirX = 0;
      player.dirY = 0;
      inputBuf = null;
    }

    player.direction =
      player.dirX > 0 ? 'right' :
      player.dirX < 0 ? 'left' :
      player.dirY < 0 ? 'up' :
      player.dirY > 0 ? 'down' : player.direction;

    // Collect yarn
    yarns = yarns.filter(d => {
      if (d.x === px && d.y === py) {
        score++;
        playAudio(sfxYarn);
        return false;
      }
      return true;
    });

    // Collect special yarn (invincibility)
    specialYarns = specialYarns.filter(d => {
      if (d.x === px && d.y === py) {
        player.invincible = INVINCIBLE_DURATION;
        score += 5;
        playAudio(sfxSpecial);
        playAudio(sfxInvincible);
        bgMusic.pause();
        return false;
      }
      return true;
    });

    // Count down invincibility
    if (player.invincible > 0) {
      player.invincible--;
      if (player.invincible === 0) {
        sfxInvincible.pause();
        if (currentState === GAME_STATE.PLAYING) {
          playAudio(bgMusic);
        }
      }
    }
  }

  // === Update Enemies ===
  function updateEnemies() {
    if (currentState !== GAME_STATE.PLAYING) return;
    frameCounter++;

    if (!gatesOpen && frameCounter >= ENEMY_SPAWN_DELAY) gatesOpen = true;

    const px = Math.floor((player.x + TILE_SIZE / 2) / TILE_SIZE);
    const py = Math.floor((player.y + TILE_SIZE / 2) / TILE_SIZE);

    enemies.forEach(e => {
      if (!gatesOpen) return;

      const centered = Math.abs(e.x - Math.round(e.x / TILE_SIZE) * TILE_SIZE) < 4 &&
                       Math.abs(e.y - Math.round(e.y / TILE_SIZE) * TILE_SIZE) < 4;

      if (centered || !e.targetSet || e.lastDir++ > 30) {
        if (Math.random() < e.intelligence) {
          const dx = player.x - e.x;
          const dy = player.y - e.y;
          e.moveX = Math.abs(dx) > Math.abs(dy) ? Math.sign(dx) : 0;
          e.moveY = Math.abs(dx) <= Math.abs(dy) ? Math.sign(dy) : 0;
        } else {
          const dirs = [{ x: 1, y: 0 }, { x: -1, y: 0 }, { x: 0, y: 1 }, { x: 0, y: -1 }];
          const rd = dirs[Math.floor(Math.random() * dirs.length)];
          e.moveX = rd.x;
          e.moveY = rd.y;
        }
        e.targetSet = true;
        e.lastDir = 0;
      }

      const ex = e.x + e.moveX * e.speed;
      const ey = e.y + e.moveY * e.speed;

      if (canMove(ex, ey, true)) {
        e.x = ex;
        e.y = ey;
      } else {
        e.targetSet = false;
      }

      const ecx = Math.floor((e.x + TILE_SIZE / 2) / TILE_SIZE);
      const ecy = Math.floor((e.y + TILE_SIZE / 2) / TILE_SIZE);

      if (ecx === px && ecy === py) {
        if (player.invincible > 0) {
          e.x = spawnPoint.col * TILE_SIZE;
          e.y = spawnPoint.row * TILE_SIZE;
          score += 10;
          playAudio(sfxMeow);
        } else {
          currentState = GAME_STATE.GAME_OVER;
          playAudio(sfxGameOver);
          bgMusic.pause();
          setTimeout(() => {
            alert(`Game Over! Score: ${score}`);
            currentState = GAME_STATE.MENU;
            startButton.style.display = 'block';
            startButton.innerText = 'Play Again';
          }, 100);
        }
      }
    });
  }

  // === Update Game ===
  function updateGame() {
    switch (currentState) {
      case GAME_STATE.PLAYING:
        updatePlayer();
        updateEnemies();
        if (yarns.length === 0 && specialYarns.length === 0) {
          currentState = GAME_STATE.WON;
          sfxInvincible.pause();
          bgMusic.pause();
          sfxYarn.pause(); sfxSpecial.pause(); sfxMeow.pause(); sfxStart.pause(); sfxGameOver.pause();
          [sfxYarn, sfxSpecial, sfxMeow, sfxStart, sfxGameOver].forEach(a => a.currentTime = 0);
          playAudio(sfxGameWon);
          winAnim = 0;
        }
        break;
      case GAME_STATE.WON:
        winAnim++;
        if (winAnim >= WIN_ANIMATION_DURATION) nextLevel();
        break;
      case GAME_STATE.LEVEL_TRANSITION:
        transTimer--;
        if (transTimer <= 0) currentState = GAME_STATE.PLAYING;
        break;
    }
  }
    // === Drawing ===
  function drawImage(img, x, y, w, h, fb) {
    if (img.complete && img.naturalWidth > 0) {
      ctx.drawImage(img, x, y, w, h);
    } else {
      ctx.fillStyle = img.fallbackColor || fb;
      ctx.fillRect(x, y, w, h);
    }
  }

  function drawMap() {
    for (let r = 0; r < map.length; r++) {
      for (let c = 0; c < map[r].length; c++) {
        let col = map[r][c] === '#' ? '#d9d4b0' : '#fff8dc';
        if (gatesOpen) gatePositions.forEach(g => {
          if (g.row === r && g.col === c) col = '#a0d8a0';
        });
        ctx.fillStyle = col;
        ctx.fillRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);
      }
    }
  }

  function drawYarns() {
    yarns.forEach(d =>
      drawImage(yarnImg, d.x * TILE_SIZE + 8, d.y * TILE_SIZE + 8, 16, 16, '#4169e1')
    );
    specialYarns.forEach(d =>
      drawImage(specialYarnImg, d.x * TILE_SIZE + 8, d.y * TILE_SIZE + 8, 16, 16, '#ffd700')
    );
  }

  function drawPlayer() {
    if (player.invincible > 0) {
      ctx.fillStyle = 'rgba(255,255,0,0.3)';
      ctx.fillRect(player.x, player.y, TILE_SIZE, TILE_SIZE);
    }
    drawImage(nuggetImgs[player.direction], player.x, player.y, TILE_SIZE, TILE_SIZE, '#ff69b4');
  }

  function drawEnemies() {
    enemies.forEach(e => {
      if (gatesOpen) drawImage(catImg, e.x, e.y, TILE_SIZE, TILE_SIZE, '#8b4513');
    });
  }

  function drawUI() {
    ctx.fillStyle = '#000';
    ctx.font = 'bold 18px Arial';
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 3;
    ctx.strokeText(`Score: ${score}`, 10, 25);
    ctx.fillText(`Score: ${score}`, 10, 25);
    ctx.strokeText(`Level: ${level}`, 10, 50);
    ctx.fillText(`Level: ${level}`, 10, 50);
    if (player.invincible > 0) {
      const t = `Invincible: ${Math.ceil(player.invincible / 60)}s`;
      ctx.strokeText(t, canvas.width - 150, 25);
      ctx.fillText(t, canvas.width - 150, 25);
    }
  }

  function drawWin() {
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    const sz = canvas.width * 0.7;
    const x = (canvas.width - sz) / 2;
    const y = (canvas.height - sz) / 2;
    const f = winAnim % 60;
    const img = f < 20 ? nuggetImgs.cheer1 : f < 40 ? nuggetImgs.cheer2 : nuggetImgs.cheer3;
    drawImage(img, x, y, sz, sz, '#ff69b4');
  }

  function drawTransition() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawMap();
    drawYarns();
    drawPlayer();
    drawEnemies();
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 32px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(`Level ${level}`, canvas.width / 2, canvas.height / 2 - 20);
    ctx.fillText('Get Ready!', canvas.width / 2, canvas.height / 2 + 20);
    ctx.textAlign = 'left';
  }

  // === Render Loop ===
  function render() {
    switch (currentState) {
      case GAME_STATE.PLAYING:
      case GAME_STATE.PAUSED:
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawMap();
        drawYarns();
        drawPlayer();
        drawEnemies();
        drawUI();
        break;
      case GAME_STATE.WON:
        drawWin();
        break;
      case GAME_STATE.LEVEL_TRANSITION:
        drawTransition();
        break;
    }
  }

  function gameLoop() {
    updateGame();
    render();
    requestAnimationFrame(gameLoop);
  }

  startButton.onclick = () => {
    startButton.style.display = 'none';
    pauseOverlay.style.display = 'none';
    resetGame();
    playAudio(sfxStart);
  };

  gameLoop();
</script>
</body>
</html>
