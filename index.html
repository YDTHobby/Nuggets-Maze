<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Nugget's Yarn Maze</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: #fef6e4;
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      overflow: hidden;
      position: fixed;
      width: 100%;
      height: 100%;
      touch-action: none;
    }
    canvas {
      display: block;
      margin: 20px auto;
      background-color: #fff8dc;
      border: 2px solid #333;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
      touch-action: none;
    }
    #gameContainer {
      position: relative;
    }
    #startButton, #pauseOverlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 16px 32px;
      font-size: 20px;
      background-color: #f9c5d1;
      border: 2px solid #333;
      border-radius: 8px;
      cursor: pointer;
      z-index: 10;
      text-align: center;
    }
    #pauseOverlay {
      background-color: rgba(249, 197, 209, 0.95);
      padding: 30px;
      display: none;
    }
    #instructions {
      margin-top: 20px;
      padding: 20px;
      background-color: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      max-width: 512px;
      text-align: center;
    }
    .controls {
      display: flex;
      justify-content: space-around;
      margin: 10px 0;
      flex-wrap: wrap;
    }
    .control {
      background-color: #f0f0f0;
      padding: 5px 10px;
      border-radius: 4px;
      margin: 2px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <button id="startButton">Start Game</button>
    <div id="pauseOverlay">
      <h2>Game Paused</h2>
      <p>Press SPACE or ESC to resume</p>
    </div>
    <canvas id="gameCanvas" width="512" height="512"></canvas>
  </div>

  <div id="instructions">
    <h3>How to Play</h3>
    <p>Help Nugget collect all the yarn while avoiding the cat!</p>
    <div class="controls">
      <span class="control">Arrow Keys: Move</span>
      <span class="control">Space/ESC: Pause</span>
    </div>
    <p>ðŸ¥¶ Blue yarn = 1 point | âœ¨ Gold yarn = 5 points + invincibility!</p>
  </div>

<script>
  // === Constants ===
  const TILE_SIZE = 32;
  const PLAYER_SPEED = 1.536; // Reduced by 20% from 1.92
  const ENEMY_SPEED = 1.536; // Reduced by 20% from 1.92
  const INVINCIBLE_DURATION = 360;
  const ENEMY_SPAWN_DELAY = 480;
  const WIN_ANIMATION_DURATION = 1000;
  const LEVEL_TRANSITION_DELAY = 3000;
  const EARLY_INPUT_THRESHOLD = 8; // Allow direction change when within 8 pixels of grid alignment

  const GAME_STATE = {
    MENU: 0,
    PLAYING: 1,
    PAUSED: 2,
    WON: 3,
    GAME_OVER: 4,
    LEVEL_TRANSITION: 5
  };

  // === Game Elements ===
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const startButton = document.getElementById('startButton');
  const pauseOverlay = document.getElementById('pauseOverlay');

  // Pre-calculate gate positions and spawn point
  const gatePositions = [];
  for (let c = 4; c <= 11; c++) gatePositions.push({ row: 6, col: c });
  const spawnPoint = { row: 7, col: 7 };

  // Define spawn house area (cat cannot return here once it leaves)
  const spawnHouse = {
    minRow: 6,
    maxRow: 8,
    minCol: 4,
    maxCol: 11
  };

  // === Game State ===
  let currentState = GAME_STATE.MENU;
  let player, enemies = [], yarns = [], specialYarns = [];
  let score = 0, level = 1, winAnim = 0, inputBuf = null, transTimer = 0;
  let gatesOpen = false, frameCounter = 0;

  // === Map Layout ===
  const map = [
    '################',
    '#......##......#',
    '#.####.##.####.#',
    '#..............#',
    '#.####.##.####.#',
    '#..............#',
    '###.########.###',
    '###.#......#.###',
    '###.########.###',
    '#..............#',
    '#.####.##.####.#',
    '#......##......#',
    '#.####.##.####.#',
    '#o............o#',
    '################'
  ];

  // === Asset Loading (Simplified) ===
  const images = {};
  const fallbackColors = {
    'nugget_up': '#ff69b4', 'nugget_down': '#ff69b4', 'nugget_left': '#ff69b4', 'nugget_right': '#ff69b4',
    'nugget_cheer1': '#ff69b4', 'nugget_cheer2': '#ff69b4', 'nugget_cheer3': '#ff69b4',
    'yarn_blue': '#4169e1', 'yarn_gold': '#ffd700', 'cat_enemy': '#8b4513'
  };

  function loadImages() {
    Object.keys(fallbackColors).forEach(key => {
      const img = new Image();
      img.src = `${key}.png`;
      img.onerror = () => img.fallbackColor = fallbackColors[key];
      images[key] = img;
    });
  }

  // === Audio (Simplified) ===
  const sounds = {};
  function createAudio(name, src, loop = false) {
    const audio = new Audio(src);
    audio.loop = loop;
    audio.addEventListener('error', () => {});
    sounds[name] = audio;
  }

  function initAudio() {
    createAudio('yarn', 'yarn_collect.mp3');
    createAudio('special', 'powerup.mp3');
    createAudio('meow', 'meow.mp3');
    createAudio('invincible', 'invincible_loop.mp3', true);
    createAudio('start', 'start_game.mp3');
    createAudio('gameOver', 'game_over.mp3');
    createAudio('gameWon', 'game_won.mp3');
    createAudio('bgMusic', 'bg_music.mp3', true);
  }

  function playSound(name) {
    try {
      const audio = sounds[name];
      if (audio) {
        audio.pause();
        audio.currentTime = 0;
        audio.play();
      }
    } catch {}
  }

  // === Initialize Game Objects ===
  function initPlayer() {
    player = {
      x: TILE_SIZE,
      y: TILE_SIZE * 3,
      dirX: 1,
      dirY: 0,
      direction: 'right',
      speed: PLAYER_SPEED,
      invincible: 0
    };
  }

  function initYarns() {
    yarns = [];
    specialYarns = [];
    map.forEach((row, r) => {
      row.split('').forEach((ch, c) => {
        if (ch === '.') yarns.push({ x: c, y: r });
        if (ch === 'o') specialYarns.push({ x: c, y: r });
      });
    });
    // Remove yarns from spawn area
    yarns = yarns.filter(d => !(d.y === spawnPoint.row && d.x >= spawnPoint.col - 2 && d.x <= spawnPoint.col + 3));
  }

  function spawnEnemies() {
    enemies = [{
      x: spawnPoint.col * TILE_SIZE,
      y: spawnPoint.row * TILE_SIZE,
      speed: ENEMY_SPEED,
      dirX: 0,
      dirY: 0,
      intelligence: Math.min(0.3 + level * 0.1, 0.9),
      hasLeftSpawn: false // Track if enemy has left the spawn house
    }];
  }

  // === Movement Helper ===
  function canMove(x, y, forEnemy = false, enemy = null) {
    const col = Math.floor((x + TILE_SIZE / 2) / TILE_SIZE);
    const row = Math.floor((y + TILE_SIZE / 2) / TILE_SIZE);
    const ch = map[row] && map[row][col];
    
    if (ch !== '#') {
      // For enemies that have left spawn, check if they're trying to re-enter spawn house
      if (forEnemy && enemy && enemy.hasLeftSpawn) {
        if (row >= spawnHouse.minRow && row <= spawnHouse.maxRow && 
            col >= spawnHouse.minCol && col <= spawnHouse.maxCol) {
          return false; // Prevent re-entry to spawn house
        }
      }
      return true;
    }
    
    // Check if enemy can pass through open gates
    if (forEnemy && gatesOpen) {
      return gatePositions.some(g => g.row === row && g.col === col);
    }
    
    return false;
  }

  function isAligned(entity) {
    const gridX = Math.round(entity.x / TILE_SIZE) * TILE_SIZE;
    const gridY = Math.round(entity.y / TILE_SIZE) * TILE_SIZE;
    return Math.abs(entity.x - gridX) < 1 && Math.abs(entity.y - gridY) < 1;
  }

  function isNearAlignment(entity) {
    const gridX = Math.round(entity.x / TILE_SIZE) * TILE_SIZE;
    const gridY = Math.round(entity.y / TILE_SIZE) * TILE_SIZE;
    return Math.abs(entity.x - gridX) < EARLY_INPUT_THRESHOLD && Math.abs(entity.y - gridY) < EARLY_INPUT_THRESHOLD;
  }

  function snapToGrid(entity) {
    entity.x = Math.round(entity.x / TILE_SIZE) * TILE_SIZE;
    entity.y = Math.round(entity.y / TILE_SIZE) * TILE_SIZE;
  }

  // === Update Player ===
  function updatePlayer() {
    if (currentState !== GAME_STATE.PLAYING) return;

    const px = Math.floor((player.x + TILE_SIZE / 2) / TILE_SIZE);
    const py = Math.floor((player.y + TILE_SIZE / 2) / TILE_SIZE);

    // Handle input when near alignment (more forgiving)
    if (isNearAlignment(player) && inputBuf) {
      // Calculate where the player would be if they were snapped to grid
      const snapX = Math.round(player.x / TILE_SIZE) * TILE_SIZE;
      const snapY = Math.round(player.y / TILE_SIZE) * TILE_SIZE;
      
      const newX = snapX + inputBuf.x * TILE_SIZE;
      const newY = snapY + inputBuf.y * TILE_SIZE;
      
      if (canMove(newX, newY)) {
        // Snap to grid and change direction
        player.x = snapX;
        player.y = snapY;
        player.dirX = inputBuf.x;
        player.dirY = inputBuf.y;
        player.direction = inputBuf.x > 0 ? 'right' : inputBuf.x < 0 ? 'left' : inputBuf.y < 0 ? 'up' : inputBuf.y > 0 ? 'down' : player.direction;
      }
      inputBuf = null;
    }

    // Try to move in current direction
    const newX = player.x + player.dirX * player.speed;
    const newY = player.y + player.dirY * player.speed;

    let canMoveX = canMove(newX, player.y);
    let canMoveY = canMove(player.x, newY);

    // Move in X direction if possible
    if (canMoveX) {
      player.x = newX;
    } else {
      // Stop X movement and snap to grid
      player.dirX = 0;
      snapToGrid(player);
    }

    // Move in Y direction if possible
    if (canMoveY) {
      player.y = newY;
    } else {
      // Stop Y movement and snap to grid
      player.dirY = 0;
      snapToGrid(player);
    }

    // Collect items
    yarns = yarns.filter(yarn => {
      if (yarn.x === px && yarn.y === py) {
        score++;
        playSound('yarn');
        return false;
      }
      return true;
    });

    specialYarns = specialYarns.filter(yarn => {
      if (yarn.x === px && yarn.y === py) {
        player.invincible = INVINCIBLE_DURATION;
        score += 5;
        playSound('special');
        playSound('invincible');
        sounds.bgMusic.pause();
        return false;
      }
      return true;
    });

    // Handle invincibility
    if (player.invincible > 0) {
      player.invincible--;
      if (player.invincible === 0) {
        sounds.invincible.pause();
        if (currentState === GAME_STATE.PLAYING) {
          playSound('bgMusic');
        }
      }
    }
  }

  // === Update Enemies ===
  function updateEnemies() {
    if (currentState !== GAME_STATE.PLAYING) return;
    
    frameCounter++;
    if (!gatesOpen && frameCounter >= ENEMY_SPAWN_DELAY) {
      gatesOpen = true;
    }

    const px = Math.floor((player.x + TILE_SIZE / 2) / TILE_SIZE);
    const py = Math.floor((player.y + TILE_SIZE / 2) / TILE_SIZE);

    enemies.forEach(enemy => {
      if (!gatesOpen) return;

      // Check if enemy has left the spawn house
      const ex = Math.floor((enemy.x + TILE_SIZE / 2) / TILE_SIZE);
      const ey = Math.floor((enemy.y + TILE_SIZE / 2) / TILE_SIZE);
      if (!enemy.hasLeftSpawn && 
          (ex < spawnHouse.minCol || ex > spawnHouse.maxCol || 
           ey < spawnHouse.minRow || ey > spawnHouse.maxRow)) {
        enemy.hasLeftSpawn = true;
      }

      // Only change direction when aligned to grid AND current direction is blocked OR no direction set
      if (isAligned(enemy) && (enemy.dirX === 0 && enemy.dirY === 0 || !canMove(enemy.x + enemy.dirX * TILE_SIZE, enemy.y + enemy.dirY * TILE_SIZE, true, enemy))) {
        
        // Get all possible directions (excluding turning around)
        const allDirs = [
          { x: 1, y: 0 }, { x: -1, y: 0 }, { x: 0, y: 1 }, { x: 0, y: -1 }
        ];
        
        // Filter out the opposite direction (turning around) and blocked directions
        const possibleDirs = allDirs.filter(dir => {
          // Don't allow turning around (opposite direction)
          if (enemy.dirX !== 0 && dir.x === -enemy.dirX) return false;
          if (enemy.dirY !== 0 && dir.y === -enemy.dirY) return false;
          
          // Check if direction is not blocked
          const testX = enemy.x + dir.x * TILE_SIZE;
          const testY = enemy.y + dir.y * TILE_SIZE;
          return canMove(testX, testY, true, enemy);
        });

        if (possibleDirs.length > 0) {
          let chosenDir;
          
          if (Math.random() < enemy.intelligence) {
            // Smart movement: choose direction closest to player
            const dx = player.x - enemy.x;
            const dy = player.y - enemy.y;
            
            chosenDir = possibleDirs.reduce((best, dir) => {
              const score = dir.x * dx + dir.y * dy; // Dot product for direction preference
              return score > best.score ? { dir, score } : best;
            }, { score: -Infinity }).dir;
          } else {
            // Random movement from available directions
            chosenDir = possibleDirs[Math.floor(Math.random() * possibleDirs.length)];
          }
          
          enemy.dirX = chosenDir.x;
          enemy.dirY = chosenDir.y;
        } else if (enemy.dirX === 0 && enemy.dirY === 0) {
          // If no direction is possible and we're stopped, pick any direction (initial movement)
          const anyDir = allDirs.find(dir => canMove(enemy.x + dir.x * TILE_SIZE, enemy.y + dir.y * TILE_SIZE, true, enemy));
          if (anyDir) {
            enemy.dirX = anyDir.x;
            enemy.dirY = anyDir.y;
          }
        }
      }

      // Move enemy
      const newX = enemy.x + enemy.dirX * enemy.speed;
      const newY = enemy.y + enemy.dirY * enemy.speed;

      if (canMove(newX, newY, true, enemy)) {
        enemy.x = newX;
        enemy.y = newY;
      } else {
        // Snap to grid when hitting wall
        snapToGrid(enemy);
        // Don't change direction here - let the next aligned check handle it
      }

      // Check collision with player
      if (ex === px && ey === py) {
        if (player.invincible > 0) {
          enemy.x = spawnPoint.col * TILE_SIZE;
          enemy.y = spawnPoint.row * TILE_SIZE;
          enemy.dirX = 0;
          enemy.dirY = 0;
          enemy.hasLeftSpawn = false; // Reset spawn status when teleported back
          score += 10;
          playSound('meow');
        } else {
          currentState = GAME_STATE.GAME_OVER;
          playSound('gameOver');
          sounds.bgMusic.pause();
          setTimeout(() => {
            alert(`Game Over! Score: ${score}`);
            currentState = GAME_STATE.MENU;
            startButton.style.display = 'block';
            startButton.innerText = 'Play Again';
          }, 100);
        }
      }
    });
  }

  // === Game Logic ===
  function resetGame() {
    initPlayer();
    score = 0;
    level = 1;
    inputBuf = null;
    initYarns();
    spawnEnemies();
    gatesOpen = false;
    frameCounter = 0;
    currentState = GAME_STATE.PLAYING;
    playSound('bgMusic');
  }

  function nextLevel() {
    level++;
    score += 100 * level;
    initYarns();
    spawnEnemies();
    gatesOpen = false;
    frameCounter = 0;
    currentState = GAME_STATE.LEVEL_TRANSITION;
    transTimer = LEVEL_TRANSITION_DELAY;
  }

  function updateGame() {
    switch (currentState) {
      case GAME_STATE.PLAYING:
        updatePlayer();
        updateEnemies();
        if (yarns.length === 0 && specialYarns.length === 0) {
          currentState = GAME_STATE.WON;
          sounds.invincible.pause();
          sounds.bgMusic.pause();
          playSound('gameWon');
          winAnim = 0;
        }
        break;
      case GAME_STATE.WON:
        winAnim++;
        if (winAnim >= WIN_ANIMATION_DURATION) nextLevel();
        break;
      case GAME_STATE.LEVEL_TRANSITION:
        transTimer--;
        if (transTimer <= 0) currentState = GAME_STATE.PLAYING;
        break;
    }
  }

  // === Drawing (Optimized) ===
  function drawImage(imgName, x, y, w, h) {
    const img = images[imgName];
    if (img && img.complete && img.naturalWidth > 0) {
      ctx.drawImage(img, x, y, w, h);
    } else {
      ctx.fillStyle = fallbackColors[imgName] || '#ff69b4';
      ctx.fillRect(x, y, w, h);
    }
  }

  function drawMap() {
    // Draw background
    ctx.fillStyle = '#fff8dc';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw walls
    ctx.fillStyle = '#d9d4b0';
    for (let r = 0; r < map.length; r++) {
      for (let c = 0; c < map[r].length; c++) {
        if (map[r][c] === '#') {
          // Check if this is a gate
          const isGate = gatesOpen && gatePositions.some(g => g.row === r && g.col === c);
          if (isGate) {
            ctx.fillStyle = '#a0d8a0';
            ctx.fillRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            ctx.fillStyle = '#d9d4b0';
          } else {
            ctx.fillRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);
          }
        }
      }
    }
  }

  function render() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    switch (currentState) {
      case GAME_STATE.PLAYING:
      case GAME_STATE.PAUSED:
        drawMap();
        
        // Draw yarns
        yarns.forEach(yarn => drawImage('yarn_blue', yarn.x * TILE_SIZE + 8, yarn.y * TILE_SIZE + 8, 16, 16));
        specialYarns.forEach(yarn => drawImage('yarn_gold', yarn.x * TILE_SIZE + 8, yarn.y * TILE_SIZE + 8, 16, 16));
        
        // Draw player with invincibility effect
        if (player.invincible > 0) {
          ctx.fillStyle = 'rgba(255,255,0,0.3)';
          ctx.fillRect(player.x, player.y, TILE_SIZE, TILE_SIZE);
        }
        drawImage(`nugget_${player.direction}`, player.x, player.y, TILE_SIZE, TILE_SIZE);
        
        // Draw enemies
        if (gatesOpen) {
          enemies.forEach(enemy => drawImage('cat_enemy', enemy.x, enemy.y, TILE_SIZE, TILE_SIZE));
        }
        
        // Draw UI
        ctx.fillStyle = '#000';
        ctx.font = 'bold 18px Arial';
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 3;
        
        ctx.strokeText(`Score: ${score}`, 10, 25);
        ctx.fillText(`Score: ${score}`, 10, 25);
        ctx.strokeText(`Level: ${level}`, 10, 50);
        ctx.fillText(`Level: ${level}`, 10, 50);
        
        if (player.invincible > 0) {
          const invText = `Invincible: ${Math.ceil(player.invincible / 60)}s`;
          ctx.strokeText(invText, canvas.width - 150, 25);
          ctx.fillText(invText, canvas.width - 150, 25);
        }
        break;
        
      case GAME_STATE.WON:
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        const cheerFrame = Math.floor(winAnim / 20) % 3;
        const cheerImg = ['nugget_cheer1', 'nugget_cheer2', 'nugget_cheer3'][cheerFrame];
        const size = canvas.width * 0.7;
        const x = (canvas.width - size) / 2;
        const y = (canvas.height - size) / 2;
        drawImage(cheerImg, x, y, size, size);
        break;
        
      case GAME_STATE.LEVEL_TRANSITION:
        drawMap();
        yarns.forEach(yarn => drawImage('yarn_blue', yarn.x * TILE_SIZE + 8, yarn.y * TILE_SIZE + 8, 16, 16));
        specialYarns.forEach(yarn => drawImage('yarn_gold', yarn.x * TILE_SIZE + 8, yarn.y * TILE_SIZE + 8, 16, 16));
        drawImage(`nugget_${player.direction}`, player.x, player.y, TILE_SIZE, TILE_SIZE);
        if (gatesOpen) enemies.forEach(enemy => drawImage('cat_enemy', enemy.x, enemy.y, TILE_SIZE, TILE_SIZE));
        
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 32px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(`Level ${level}`, canvas.width / 2, canvas.height / 2 - 20);
        ctx.fillText('Get Ready!', canvas.width / 2, canvas.height / 2 + 20);
        ctx.textAlign = 'left';
        break;
    }
  }

  // === Input Handling ===
  document.addEventListener('keydown', e => {
    if (currentState === GAME_STATE.PLAYING) {
      const keyMap = {
        'ArrowUp': { x: 0, y: -1 },
        'ArrowDown': { x: 0, y: 1 },
        'ArrowLeft': { x: -1, y: 0 },
        'ArrowRight': { x: 1, y: 0 }
      };
      if (keyMap[e.key]) {
        e.preventDefault();
        inputBuf = keyMap[e.key];
      }
    }
    
    if ((e.key === ' ' || e.key === 'Escape') && 
        (currentState === GAME_STATE.PLAYING || currentState === GAME_STATE.PAUSED)) {
      e.preventDefault();
      if (currentState === GAME_STATE.PLAYING) {
        currentState = GAME_STATE.PAUSED;
        pauseOverlay.style.display = 'block';
        sounds.bgMusic.pause();
      } else {
        currentState = GAME_STATE.PLAYING;
        pauseOverlay.style.display = 'none';
        playSound('bgMusic');
      }
    }
  });

  // === Touch Controls ===
  let touchStartX = 0, touchStartY = 0;

  // Prevent default touch behaviors
  document.addEventListener('touchstart', e => e.preventDefault(), { passive: false });
  document.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
  document.addEventListener('touchend', e => e.preventDefault(), { passive: false });

  canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    if (e.touches.length === 1) {
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
    }
  }, { passive: false });

  canvas.addEventListener('touchend', e => {
    e.preventDefault();
    if (e.changedTouches.length === 1 && currentState === GAME_STATE.PLAYING) {
      const dx = e.changedTouches[0].clientX - touchStartX;
      const dy = e.changedTouches[0].clientY - touchStartY;
      const absDx = Math.abs(dx);
      const absDy = Math.abs(dy);
      
      if (Math.max(absDx, absDy) > 30) {
        if (absDx > absDy) {
          inputBuf = dx > 0 ? { x: 1, y: 0 } : { x: -1, y: 0 };
        } else {
          inputBuf = dy > 0 ? { x: 0, y: 1 } : { x: 0, y: -1 };
        }
      }
    }
  }, { passive: false });

  // === Game Loop ===
  function gameLoop() {
    updateGame();
    render();
    requestAnimationFrame(gameLoop);
  }

  // === Initialization ===
  loadImages();
  initAudio();

  startButton.onclick = () => {
    startButton.style.display = 'none';
    pauseOverlay.style.display = 'none';
    resetGame();
    playSound('start');
  };

  gameLoop();
</script>
</body>
</html>
